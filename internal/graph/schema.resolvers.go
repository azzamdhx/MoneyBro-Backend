package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.49

import (
	"context"
	"time"

	"github.com/azzamdhx/moneybro/backend/internal/graph/model"
	"github.com/azzamdhx/moneybro/backend/internal/middleware"
	"github.com/azzamdhx/moneybro/backend/internal/models"
	"github.com/azzamdhx/moneybro/backend/internal/repository"
	"github.com/azzamdhx/moneybro/backend/internal/services"
	"github.com/azzamdhx/moneybro/backend/internal/utils"
	"github.com/google/uuid"
)

func (r *mutationResolver) Register(ctx context.Context, input model.RegisterInput) (*model.AuthPayload, error) {
	result, err := r.Services.Auth.Register(input.Email, input.Password, input.Name)
	if err != nil {
		return nil, err
	}
	return &model.AuthPayload{
		Token: result.Token,
		User:  userToModel(result.User),
	}, nil
}

func (r *mutationResolver) Login(ctx context.Context, input model.LoginInput) (*model.AuthPayload, error) {
	result, err := r.Services.Auth.Login(input.Email, input.Password)
	if err != nil {
		return nil, err
	}
	return &model.AuthPayload{
		Token: result.Token,
		User:  userToModel(result.User),
	}, nil
}

func (r *mutationResolver) UpdateProfile(ctx context.Context, input model.UpdateProfileInput) (*model.User, error) {
	userID, ok := middleware.GetUserID(ctx)
	if !ok {
		return nil, utils.ErrUnauthorized
	}
	user, err := r.Services.User.UpdateProfile(userID, input.Name, input.Password)
	if err != nil {
		return nil, err
	}
	return userToModel(user), nil
}

func (r *mutationResolver) CreateCategory(ctx context.Context, input model.CreateCategoryInput) (*model.Category, error) {
	userID, ok := middleware.GetUserID(ctx)
	if !ok {
		return nil, utils.ErrUnauthorized
	}
	cat, err := r.Services.Category.Create(userID, input.Name)
	if err != nil {
		return nil, err
	}
	return categoryToModel(cat), nil
}

func (r *mutationResolver) UpdateCategory(ctx context.Context, id uuid.UUID, input model.UpdateCategoryInput) (*model.Category, error) {
	cat, err := r.Services.Category.Update(id, input.Name)
	if err != nil {
		return nil, err
	}
	return categoryToModel(cat), nil
}

func (r *mutationResolver) DeleteCategory(ctx context.Context, id uuid.UUID) (bool, error) {
	err := r.Services.Category.Delete(id)
	return err == nil, err
}

func (r *mutationResolver) CreateExpense(ctx context.Context, input model.CreateExpenseInput) (*model.Expense, error) {
	userID, ok := middleware.GetUserID(ctx)
	if !ok {
		return nil, utils.ErrUnauthorized
	}
	exp, err := r.Services.Expense.Create(userID, services.CreateExpenseInput{
		CategoryID:  input.CategoryID,
		ItemName:    input.ItemName,
		UnitPrice:   int64(input.UnitPrice),
		Quantity:    input.Quantity,
		Notes:       input.Notes,
		ExpenseDate: input.ExpenseDate,
	})
	if err != nil {
		return nil, err
	}
	return expenseToModel(exp), nil
}

func (r *mutationResolver) UpdateExpense(ctx context.Context, id uuid.UUID, input model.UpdateExpenseInput) (*model.Expense, error) {
	var unitPrice *int64
	if input.UnitPrice != nil {
		v := int64(*input.UnitPrice)
		unitPrice = &v
	}
	exp, err := r.Services.Expense.Update(id, services.UpdateExpenseInput{
		CategoryID:  input.CategoryID,
		ItemName:    input.ItemName,
		UnitPrice:   unitPrice,
		Quantity:    input.Quantity,
		Notes:       input.Notes,
		ExpenseDate: input.ExpenseDate,
	})
	if err != nil {
		return nil, err
	}
	return expenseToModel(exp), nil
}

func (r *mutationResolver) DeleteExpense(ctx context.Context, id uuid.UUID) (bool, error) {
	err := r.Services.Expense.Delete(id)
	return err == nil, err
}

func (r *mutationResolver) CreateExpenseTemplate(ctx context.Context, input model.CreateExpenseTemplateInput) (*model.ExpenseTemplate, error) {
	userID, ok := middleware.GetUserID(ctx)
	if !ok {
		return nil, utils.ErrUnauthorized
	}
	tmpl, err := r.Services.ExpenseTemplate.Create(userID, services.CreateExpenseTemplateInput{
		CategoryID:   input.CategoryID,
		ItemName:     input.ItemName,
		UnitPrice:    int64(input.UnitPrice),
		Quantity:     input.Quantity,
		RecurringDay: input.RecurringDay,
		Notes:        input.Notes,
	})
	if err != nil {
		return nil, err
	}
	return expenseTemplateToModel(tmpl), nil
}

func (r *mutationResolver) UpdateExpenseTemplate(ctx context.Context, id uuid.UUID, input model.UpdateExpenseTemplateInput) (*model.ExpenseTemplate, error) {
	tmpl, err := r.Services.ExpenseTemplate.GetByID(id)
	if err != nil {
		return nil, err
	}
	categoryID := tmpl.CategoryID
	if input.CategoryID != nil {
		categoryID = *input.CategoryID
	}
	itemName := tmpl.ItemName
	if input.ItemName != nil {
		itemName = *input.ItemName
	}
	unitPrice := tmpl.UnitPrice
	if input.UnitPrice != nil {
		unitPrice = int64(*input.UnitPrice)
	}
	quantity := tmpl.Quantity
	if input.Quantity != nil {
		quantity = *input.Quantity
	}
	updated, err := r.Services.ExpenseTemplate.Update(id, services.CreateExpenseTemplateInput{
		CategoryID:   categoryID,
		ItemName:     itemName,
		UnitPrice:    unitPrice,
		Quantity:     quantity,
		RecurringDay: input.RecurringDay,
		Notes:        input.Notes,
	})
	if err != nil {
		return nil, err
	}
	return expenseTemplateToModel(updated), nil
}

func (r *mutationResolver) DeleteExpenseTemplate(ctx context.Context, id uuid.UUID) (bool, error) {
	err := r.Services.ExpenseTemplate.Delete(id)
	return err == nil, err
}

func (r *mutationResolver) CreateExpenseFromTemplate(ctx context.Context, templateID uuid.UUID, expenseDate *time.Time) (*model.Expense, error) {
	userID, ok := middleware.GetUserID(ctx)
	if !ok {
		return nil, utils.ErrUnauthorized
	}
	exp, err := r.Services.ExpenseTemplate.CreateExpenseFromTemplate(userID, templateID, expenseDate)
	if err != nil {
		return nil, err
	}
	return expenseToModel(exp), nil
}

func (r *mutationResolver) CreateInstallment(ctx context.Context, input model.CreateInstallmentInput) (*model.Installment, error) {
	userID, ok := middleware.GetUserID(ctx)
	if !ok {
		return nil, utils.ErrUnauthorized
	}
	inst, err := r.Services.Installment.Create(userID, services.CreateInstallmentInput{
		Name:           input.Name,
		ActualAmount:   int64(input.ActualAmount),
		LoanAmount:     int64(input.LoanAmount),
		MonthlyPayment: int64(input.MonthlyPayment),
		Tenor:          input.Tenor,
		StartDate:      input.StartDate,
		DueDay:         input.DueDay,
		Notes:          input.Notes,
	})
	if err != nil {
		return nil, err
	}
	return installmentToModel(inst), nil
}

func (r *mutationResolver) UpdateInstallment(ctx context.Context, id uuid.UUID, input model.UpdateInstallmentInput) (*model.Installment, error) {
	inst, err := r.Services.Installment.GetByID(id)
	if err != nil {
		return nil, err
	}
	name := inst.Name
	if input.Name != nil {
		name = *input.Name
	}
	actualAmount := inst.ActualAmount
	if input.ActualAmount != nil {
		actualAmount = int64(*input.ActualAmount)
	}
	loanAmount := inst.LoanAmount
	if input.LoanAmount != nil {
		loanAmount = int64(*input.LoanAmount)
	}
	monthlyPayment := inst.MonthlyPayment
	if input.MonthlyPayment != nil {
		monthlyPayment = int64(*input.MonthlyPayment)
	}
	tenor := inst.Tenor
	if input.Tenor != nil {
		tenor = *input.Tenor
	}
	startDate := inst.StartDate
	if input.StartDate != nil {
		startDate = *input.StartDate
	}
	dueDay := inst.DueDay
	if input.DueDay != nil {
		dueDay = *input.DueDay
	}
	var status *models.InstallmentStatus
	if input.Status != nil {
		s := models.InstallmentStatus(*input.Status)
		status = &s
	}
	updated, err := r.Services.Installment.Update(id, services.CreateInstallmentInput{
		Name:           name,
		ActualAmount:   actualAmount,
		LoanAmount:     loanAmount,
		MonthlyPayment: monthlyPayment,
		Tenor:          tenor,
		StartDate:      startDate,
		DueDay:         dueDay,
		Notes:          input.Notes,
	}, status)
	if err != nil {
		return nil, err
	}
	return installmentToModel(updated), nil
}

func (r *mutationResolver) DeleteInstallment(ctx context.Context, id uuid.UUID) (bool, error) {
	err := r.Services.Installment.Delete(id)
	return err == nil, err
}

func (r *mutationResolver) RecordInstallmentPayment(ctx context.Context, input model.RecordInstallmentPaymentInput) (*model.InstallmentPayment, error) {
	payment, err := r.Services.Installment.RecordPayment(input.InstallmentID, int64(input.Amount), input.PaidAt)
	if err != nil {
		return nil, err
	}
	return installmentPaymentToModel(payment), nil
}

func (r *mutationResolver) CreateDebt(ctx context.Context, input model.CreateDebtInput) (*model.Debt, error) {
	userID, ok := middleware.GetUserID(ctx)
	if !ok {
		return nil, utils.ErrUnauthorized
	}
	var loanAmount *int64
	if input.LoanAmount != nil {
		v := int64(*input.LoanAmount)
		loanAmount = &v
	}
	var monthlyPayment *int64
	if input.MonthlyPayment != nil {
		v := int64(*input.MonthlyPayment)
		monthlyPayment = &v
	}
	debt, err := r.Services.Debt.Create(userID, services.CreateDebtInput{
		PersonName:     input.PersonName,
		ActualAmount:   int64(input.ActualAmount),
		LoanAmount:     loanAmount,
		PaymentType:    models.DebtPaymentType(input.PaymentType),
		MonthlyPayment: monthlyPayment,
		Tenor:          input.Tenor,
		DueDate:        input.DueDate,
		Notes:          input.Notes,
	})
	if err != nil {
		return nil, err
	}
	return debtToModel(debt), nil
}

func (r *mutationResolver) UpdateDebt(ctx context.Context, id uuid.UUID, input model.UpdateDebtInput) (*model.Debt, error) {
	debt, err := r.Services.Debt.GetByID(id)
	if err != nil {
		return nil, err
	}
	personName := debt.PersonName
	if input.PersonName != nil {
		personName = *input.PersonName
	}
	actualAmount := debt.ActualAmount
	if input.ActualAmount != nil {
		actualAmount = int64(*input.ActualAmount)
	}
	loanAmount := debt.LoanAmount
	if input.LoanAmount != nil {
		v := int64(*input.LoanAmount)
		loanAmount = &v
	}
	paymentType := debt.PaymentType
	if input.PaymentType != nil {
		paymentType = models.DebtPaymentType(*input.PaymentType)
	}
	monthlyPayment := debt.MonthlyPayment
	if input.MonthlyPayment != nil {
		v := int64(*input.MonthlyPayment)
		monthlyPayment = &v
	}
	tenor := debt.Tenor
	if input.Tenor != nil {
		tenor = input.Tenor
	}
	dueDate := debt.DueDate
	if input.DueDate != nil {
		dueDate = input.DueDate
	}
	var status *models.DebtStatus
	if input.Status != nil {
		s := models.DebtStatus(*input.Status)
		status = &s
	}
	updated, err := r.Services.Debt.Update(id, services.CreateDebtInput{
		PersonName:     personName,
		ActualAmount:   actualAmount,
		LoanAmount:     loanAmount,
		PaymentType:    paymentType,
		MonthlyPayment: monthlyPayment,
		Tenor:          tenor,
		DueDate:        dueDate,
		Notes:          input.Notes,
	}, status)
	if err != nil {
		return nil, err
	}
	return debtToModel(updated), nil
}

func (r *mutationResolver) DeleteDebt(ctx context.Context, id uuid.UUID) (bool, error) {
	err := r.Services.Debt.Delete(id)
	return err == nil, err
}

func (r *mutationResolver) RecordDebtPayment(ctx context.Context, input model.RecordDebtPaymentInput) (*model.DebtPayment, error) {
	payment, err := r.Services.Debt.RecordPayment(input.DebtID, int64(input.Amount), input.PaidAt)
	if err != nil {
		return nil, err
	}
	return debtPaymentToModel(payment), nil
}

func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	userID, ok := middleware.GetUserID(ctx)
	if !ok {
		return nil, utils.ErrUnauthorized
	}
	user, err := r.Services.User.GetByID(userID)
	if err != nil {
		return nil, err
	}
	return userToModel(user), nil
}

func (r *queryResolver) Categories(ctx context.Context) ([]*model.Category, error) {
	userID, ok := middleware.GetUserID(ctx)
	if !ok {
		return nil, utils.ErrUnauthorized
	}
	cats, err := r.Services.Category.GetByUserID(userID)
	if err != nil {
		return nil, err
	}
	result := make([]*model.Category, len(cats))
	for i, c := range cats {
		result[i] = categoryToModel(&c)
	}
	return result, nil
}

func (r *queryResolver) Category(ctx context.Context, id uuid.UUID) (*model.Category, error) {
	cat, err := r.Services.Category.GetByID(id)
	if err != nil {
		return nil, err
	}
	return categoryToModel(cat), nil
}

func (r *queryResolver) Expenses(ctx context.Context, filter *model.ExpenseFilter) ([]*model.Expense, error) {
	userID, ok := middleware.GetUserID(ctx)
	if !ok {
		return nil, utils.ErrUnauthorized
	}
	var repoFilter *repository.ExpenseFilter
	if filter != nil {
		repoFilter = &repository.ExpenseFilter{
			CategoryID: filter.CategoryID,
		}
		if filter.StartDate != nil {
			s := filter.StartDate.Format("2006-01-02")
			repoFilter.StartDate = &s
		}
		if filter.EndDate != nil {
			e := filter.EndDate.Format("2006-01-02")
			repoFilter.EndDate = &e
		}
	}
	exps, err := r.Services.Expense.GetByUserID(userID, repoFilter)
	if err != nil {
		return nil, err
	}
	result := make([]*model.Expense, len(exps))
	for i, e := range exps {
		result[i] = expenseToModel(&e)
	}
	return result, nil
}

func (r *queryResolver) Expense(ctx context.Context, id uuid.UUID) (*model.Expense, error) {
	exp, err := r.Services.Expense.GetByID(id)
	if err != nil {
		return nil, err
	}
	return expenseToModel(exp), nil
}

func (r *queryResolver) ExpenseTemplates(ctx context.Context) ([]*model.ExpenseTemplate, error) {
	userID, ok := middleware.GetUserID(ctx)
	if !ok {
		return nil, utils.ErrUnauthorized
	}
	tmpls, err := r.Services.ExpenseTemplate.GetByUserID(userID)
	if err != nil {
		return nil, err
	}
	result := make([]*model.ExpenseTemplate, len(tmpls))
	for i, t := range tmpls {
		result[i] = expenseTemplateToModel(&t)
	}
	return result, nil
}

func (r *queryResolver) ExpenseTemplate(ctx context.Context, id uuid.UUID) (*model.ExpenseTemplate, error) {
	tmpl, err := r.Services.ExpenseTemplate.GetByID(id)
	if err != nil {
		return nil, err
	}
	return expenseTemplateToModel(tmpl), nil
}

func (r *queryResolver) Installments(ctx context.Context, status *model.InstallmentStatus) ([]*model.Installment, error) {
	userID, ok := middleware.GetUserID(ctx)
	if !ok {
		return nil, utils.ErrUnauthorized
	}
	var s *models.InstallmentStatus
	if status != nil {
		st := models.InstallmentStatus(*status)
		s = &st
	}
	insts, err := r.Services.Installment.GetByUserID(userID, s)
	if err != nil {
		return nil, err
	}
	result := make([]*model.Installment, len(insts))
	for i, inst := range insts {
		result[i] = installmentToModel(&inst)
	}
	return result, nil
}

func (r *queryResolver) Installment(ctx context.Context, id uuid.UUID) (*model.Installment, error) {
	inst, err := r.Services.Installment.GetByID(id)
	if err != nil {
		return nil, err
	}
	return installmentToModel(inst), nil
}

func (r *queryResolver) Debts(ctx context.Context, status *model.DebtStatus) ([]*model.Debt, error) {
	userID, ok := middleware.GetUserID(ctx)
	if !ok {
		return nil, utils.ErrUnauthorized
	}
	var s *models.DebtStatus
	if status != nil {
		st := models.DebtStatus(*status)
		s = &st
	}
	debts, err := r.Services.Debt.GetByUserID(userID, s)
	if err != nil {
		return nil, err
	}
	result := make([]*model.Debt, len(debts))
	for i, d := range debts {
		result[i] = debtToModel(&d)
	}
	return result, nil
}

func (r *queryResolver) Debt(ctx context.Context, id uuid.UUID) (*model.Debt, error) {
	debt, err := r.Services.Debt.GetByID(id)
	if err != nil {
		return nil, err
	}
	return debtToModel(debt), nil
}

func (r *queryResolver) Dashboard(ctx context.Context) (*model.Dashboard, error) {
	userID, ok := middleware.GetUserID(ctx)
	if !ok {
		return nil, utils.ErrUnauthorized
	}
	dash, err := r.Services.Dashboard.GetDashboard(userID)
	if err != nil {
		return nil, err
	}
	return dashboardToModel(dash), nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
