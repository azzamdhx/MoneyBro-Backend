package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.49

import (
	"context"
	"fmt"
	"time"

	"github.com/azzamdhx/moneybro/backend/internal/graph/model"
	"github.com/azzamdhx/moneybro/backend/internal/middleware"
	"github.com/azzamdhx/moneybro/backend/internal/models"
	"github.com/azzamdhx/moneybro/backend/internal/repository"
	"github.com/azzamdhx/moneybro/backend/internal/services"
	"github.com/azzamdhx/moneybro/backend/internal/utils"
	"github.com/google/uuid"
)

// Register is the resolver for the register field.
func (r *mutationResolver) Register(ctx context.Context, input model.RegisterInput) (*model.AuthPayload, error) {
	result, err := r.Services.Auth.Register(input.Email, input.Password, input.Name)
	if err != nil {
		return nil, err
	}
	token := result.Token
	return &model.AuthPayload{
		Token: &token,
		User:  userToModel(result.User),
	}, nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input model.LoginInput) (*model.AuthPayload, error) {
	result, err := r.Services.Auth.Login(ctx, input.Email, input.Password)
	if err != nil {
		return nil, err
	}

	// If 2FA is required, return tempToken
	if result.Requires2FA {
		return &model.AuthPayload{
			Requires2fa: true,
			TempToken:   &result.TempToken,
		}, nil
	}

	return &model.AuthPayload{
		Token:       &result.Token,
		User:        userToModel(result.User),
		Requires2fa: false,
	}, nil
}

// Verify2fa is the resolver for the verify2FA field.
func (r *mutationResolver) Verify2fa(ctx context.Context, input model.Verify2FAInput) (*model.TwoFAPayload, error) {
	result, err := r.Services.Auth.Verify2FA(ctx, input.TempToken, input.Code)
	if err != nil {
		return nil, err
	}
	return &model.TwoFAPayload{
		Token: result.Token,
		User:  userToModel(result.User),
	}, nil
}

// Resend2FACode is the resolver for the resend2FACode field.
func (r *mutationResolver) Resend2FACode(ctx context.Context, tempToken string) (bool, error) {
	panic(fmt.Errorf("not implemented: Resend2FACode - resend2FACode"))
}

// Enable2fa is the resolver for the enable2FA field.
func (r *mutationResolver) Enable2fa(ctx context.Context, password string) (bool, error) {
	userID, ok := middleware.GetUserID(ctx)
	if !ok {
		return false, utils.ErrUnauthorized
	}
	if err := r.Services.Auth.Enable2FA(userID, password); err != nil {
		return false, err
	}
	return true, nil
}

// Disable2fa is the resolver for the disable2FA field.
func (r *mutationResolver) Disable2fa(ctx context.Context, password string) (bool, error) {
	userID, ok := middleware.GetUserID(ctx)
	if !ok {
		return false, utils.ErrUnauthorized
	}
	if err := r.Services.Auth.Disable2FA(userID, password); err != nil {
		return false, err
	}
	return true, nil
}

// UpdateProfile is the resolver for the updateProfile field.
func (r *mutationResolver) UpdateProfile(ctx context.Context, input model.UpdateProfileInput) (*model.User, error) {
	userID, ok := middleware.GetUserID(ctx)
	if !ok {
		return nil, utils.ErrUnauthorized
	}
	user, err := r.Services.User.UpdateProfile(userID, input.Name, input.Email, input.CurrentPassword, input.Password)
	if err != nil {
		return nil, err
	}
	return userToModel(user), nil
}

// UpdateNotificationSettings is the resolver for the updateNotificationSettings field.
func (r *mutationResolver) UpdateNotificationSettings(ctx context.Context, input model.UpdateNotificationSettingsInput) (*model.User, error) {
	userID, ok := middleware.GetUserID(ctx)
	if !ok {
		return nil, utils.ErrUnauthorized
	}
	user, err := r.Services.User.UpdateNotificationSettings(userID, input.NotifyInstallment, input.NotifyDebt, input.NotifyDaysBefore)
	if err != nil {
		return nil, err
	}
	return userToModel(user), nil
}

// DeleteAccount is the resolver for the deleteAccount field.
func (r *mutationResolver) DeleteAccount(ctx context.Context, input model.DeleteAccountInput) (bool, error) {
	userID, ok := middleware.GetUserID(ctx)
	if !ok {
		return false, utils.ErrUnauthorized
	}
	if err := r.Services.User.DeleteAccount(userID, input.Password); err != nil {
		return false, err
	}
	return true, nil
}

// ForgotPassword is the resolver for the forgotPassword field.
func (r *mutationResolver) ForgotPassword(ctx context.Context, input model.ForgotPasswordInput) (bool, error) {
	if err := r.Services.Auth.ForgotPassword(ctx, input.Email); err != nil {
		return false, err
	}
	return true, nil
}

// ResetPassword is the resolver for the resetPassword field.
func (r *mutationResolver) ResetPassword(ctx context.Context, input model.ResetPasswordInput) (bool, error) {
	if err := r.Services.Auth.ResetPassword(input.Token, input.Password); err != nil {
		return false, err
	}
	return true, nil
}

// CreateCategory is the resolver for the createCategory field.
func (r *mutationResolver) CreateCategory(ctx context.Context, input model.CreateCategoryInput) (*model.Category, error) {
	userID, ok := middleware.GetUserID(ctx)
	if !ok {
		return nil, utils.ErrUnauthorized
	}
	cat, err := r.Services.Category.Create(userID, input.Name)
	if err != nil {
		return nil, err
	}
	return categoryToModel(cat), nil
}

// UpdateCategory is the resolver for the updateCategory field.
func (r *mutationResolver) UpdateCategory(ctx context.Context, id uuid.UUID, input model.UpdateCategoryInput) (*model.Category, error) {
	cat, err := r.Services.Category.Update(id, input.Name)
	if err != nil {
		return nil, err
	}
	return categoryToModel(cat), nil
}

// DeleteCategory is the resolver for the deleteCategory field.
func (r *mutationResolver) DeleteCategory(ctx context.Context, id uuid.UUID) (bool, error) {
	err := r.Services.Category.Delete(id)
	return err == nil, err
}

// CreateExpense is the resolver for the createExpense field.
func (r *mutationResolver) CreateExpense(ctx context.Context, input model.CreateExpenseInput) (*model.Expense, error) {
	userID, ok := middleware.GetUserID(ctx)
	if !ok {
		return nil, utils.ErrUnauthorized
	}
	exp, err := r.Services.Expense.Create(userID, services.CreateExpenseInput{
		CategoryID:  input.CategoryID,
		ItemName:    input.ItemName,
		UnitPrice:   int64(input.UnitPrice),
		Quantity:    input.Quantity,
		Notes:       input.Notes,
		ExpenseDate: input.ExpenseDate,
	})
	if err != nil {
		return nil, err
	}
	return expenseToModel(exp), nil
}

// UpdateExpense is the resolver for the updateExpense field.
func (r *mutationResolver) UpdateExpense(ctx context.Context, id uuid.UUID, input model.UpdateExpenseInput) (*model.Expense, error) {
	var unitPrice *int64
	if input.UnitPrice != nil {
		v := int64(*input.UnitPrice)
		unitPrice = &v
	}
	exp, err := r.Services.Expense.Update(id, services.UpdateExpenseInput{
		CategoryID:  input.CategoryID,
		ItemName:    input.ItemName,
		UnitPrice:   unitPrice,
		Quantity:    input.Quantity,
		Notes:       input.Notes,
		ExpenseDate: input.ExpenseDate,
	})
	if err != nil {
		return nil, err
	}
	return expenseToModel(exp), nil
}

// DeleteExpense is the resolver for the deleteExpense field.
func (r *mutationResolver) DeleteExpense(ctx context.Context, id uuid.UUID) (bool, error) {
	err := r.Services.Expense.Delete(id)
	return err == nil, err
}

// CreateExpenseTemplate is the resolver for the createExpenseTemplate field.
func (r *mutationResolver) CreateExpenseTemplate(ctx context.Context, input model.CreateExpenseTemplateInput) (*model.ExpenseTemplate, error) {
	userID, ok := middleware.GetUserID(ctx)
	if !ok {
		return nil, utils.ErrUnauthorized
	}
	tmpl, err := r.Services.ExpenseTemplate.Create(userID, services.CreateExpenseTemplateInput{
		CategoryID:   input.CategoryID,
		ItemName:     input.ItemName,
		UnitPrice:    int64(input.UnitPrice),
		Quantity:     input.Quantity,
		RecurringDay: input.RecurringDay,
		Notes:        input.Notes,
	})
	if err != nil {
		return nil, err
	}
	return expenseTemplateToModel(tmpl), nil
}

// UpdateExpenseTemplate is the resolver for the updateExpenseTemplate field.
func (r *mutationResolver) UpdateExpenseTemplate(ctx context.Context, id uuid.UUID, input model.UpdateExpenseTemplateInput) (*model.ExpenseTemplate, error) {
	tmpl, err := r.Services.ExpenseTemplate.GetByID(id)
	if err != nil {
		return nil, err
	}
	categoryID := tmpl.CategoryID
	if input.CategoryID != nil {
		categoryID = *input.CategoryID
	}
	itemName := tmpl.ItemName
	if input.ItemName != nil {
		itemName = *input.ItemName
	}
	unitPrice := tmpl.UnitPrice
	if input.UnitPrice != nil {
		unitPrice = int64(*input.UnitPrice)
	}
	quantity := tmpl.Quantity
	if input.Quantity != nil {
		quantity = *input.Quantity
	}
	updated, err := r.Services.ExpenseTemplate.Update(id, services.CreateExpenseTemplateInput{
		CategoryID:   categoryID,
		ItemName:     itemName,
		UnitPrice:    unitPrice,
		Quantity:     quantity,
		RecurringDay: input.RecurringDay,
		Notes:        input.Notes,
	})
	if err != nil {
		return nil, err
	}
	return expenseTemplateToModel(updated), nil
}

// DeleteExpenseTemplate is the resolver for the deleteExpenseTemplate field.
func (r *mutationResolver) DeleteExpenseTemplate(ctx context.Context, id uuid.UUID) (bool, error) {
	err := r.Services.ExpenseTemplate.Delete(id)
	return err == nil, err
}

// CreateExpenseFromTemplate is the resolver for the createExpenseFromTemplate field.
func (r *mutationResolver) CreateExpenseFromTemplate(ctx context.Context, templateID uuid.UUID, expenseDate *time.Time) (*model.Expense, error) {
	userID, ok := middleware.GetUserID(ctx)
	if !ok {
		return nil, utils.ErrUnauthorized
	}
	exp, err := r.Services.ExpenseTemplate.CreateExpenseFromTemplate(userID, templateID, expenseDate)
	if err != nil {
		return nil, err
	}
	return expenseToModel(exp), nil
}

// CreateInstallment is the resolver for the createInstallment field.
func (r *mutationResolver) CreateInstallment(ctx context.Context, input model.CreateInstallmentInput) (*model.Installment, error) {
	userID, ok := middleware.GetUserID(ctx)
	if !ok {
		return nil, utils.ErrUnauthorized
	}
	inst, err := r.Services.Installment.Create(userID, services.CreateInstallmentInput{
		Name:           input.Name,
		ActualAmount:   int64(input.ActualAmount),
		LoanAmount:     int64(input.LoanAmount),
		MonthlyPayment: int64(input.MonthlyPayment),
		Tenor:          input.Tenor,
		StartDate:      input.StartDate,
		DueDay:         input.DueDay,
		Notes:          input.Notes,
	})
	if err != nil {
		return nil, err
	}
	return installmentToModel(inst), nil
}

// UpdateInstallment is the resolver for the updateInstallment field.
func (r *mutationResolver) UpdateInstallment(ctx context.Context, id uuid.UUID, input model.UpdateInstallmentInput) (*model.Installment, error) {
	inst, err := r.Services.Installment.GetByID(id)
	if err != nil {
		return nil, err
	}
	name := inst.Name
	if input.Name != nil {
		name = *input.Name
	}
	actualAmount := inst.ActualAmount
	if input.ActualAmount != nil {
		actualAmount = int64(*input.ActualAmount)
	}
	loanAmount := inst.LoanAmount
	if input.LoanAmount != nil {
		loanAmount = int64(*input.LoanAmount)
	}
	monthlyPayment := inst.MonthlyPayment
	if input.MonthlyPayment != nil {
		monthlyPayment = int64(*input.MonthlyPayment)
	}
	tenor := inst.Tenor
	if input.Tenor != nil {
		tenor = *input.Tenor
	}
	startDate := inst.StartDate
	if input.StartDate != nil {
		startDate = *input.StartDate
	}
	dueDay := inst.DueDay
	if input.DueDay != nil {
		dueDay = *input.DueDay
	}
	var status *models.InstallmentStatus
	if input.Status != nil {
		s := models.InstallmentStatus(*input.Status)
		status = &s
	}
	updated, err := r.Services.Installment.Update(id, services.CreateInstallmentInput{
		Name:           name,
		ActualAmount:   actualAmount,
		LoanAmount:     loanAmount,
		MonthlyPayment: monthlyPayment,
		Tenor:          tenor,
		StartDate:      startDate,
		DueDay:         dueDay,
		Notes:          input.Notes,
	}, status)
	if err != nil {
		return nil, err
	}
	return installmentToModel(updated), nil
}

// DeleteInstallment is the resolver for the deleteInstallment field.
func (r *mutationResolver) DeleteInstallment(ctx context.Context, id uuid.UUID) (bool, error) {
	err := r.Services.Installment.Delete(id)
	return err == nil, err
}

// RecordInstallmentPayment is the resolver for the recordInstallmentPayment field.
func (r *mutationResolver) RecordInstallmentPayment(ctx context.Context, input model.RecordInstallmentPaymentInput) (*model.InstallmentPayment, error) {
	payment, err := r.Services.Installment.RecordPayment(input.InstallmentID, int64(input.Amount), input.PaidAt)
	if err != nil {
		return nil, err
	}
	return installmentPaymentToModel(payment), nil
}

// MarkInstallmentComplete is the resolver for the markInstallmentComplete field.
func (r *mutationResolver) MarkInstallmentComplete(ctx context.Context, id uuid.UUID) (*model.Installment, error) {
	installment, err := r.Services.Installment.MarkComplete(id)
	if err != nil {
		return nil, err
	}
	return installmentToModel(installment), nil
}

// CreateDebt is the resolver for the createDebt field.
func (r *mutationResolver) CreateDebt(ctx context.Context, input model.CreateDebtInput) (*model.Debt, error) {
	userID, ok := middleware.GetUserID(ctx)
	if !ok {
		return nil, utils.ErrUnauthorized
	}
	var loanAmount *int64
	if input.LoanAmount != nil {
		v := int64(*input.LoanAmount)
		loanAmount = &v
	}
	var monthlyPayment *int64
	if input.MonthlyPayment != nil {
		v := int64(*input.MonthlyPayment)
		monthlyPayment = &v
	}
	debt, err := r.Services.Debt.Create(userID, services.CreateDebtInput{
		PersonName:     input.PersonName,
		ActualAmount:   int64(input.ActualAmount),
		LoanAmount:     loanAmount,
		PaymentType:    models.DebtPaymentType(input.PaymentType),
		MonthlyPayment: monthlyPayment,
		Tenor:          input.Tenor,
		DueDate:        input.DueDate,
		Notes:          input.Notes,
	})
	if err != nil {
		return nil, err
	}
	return debtToModel(debt), nil
}

// UpdateDebt is the resolver for the updateDebt field.
func (r *mutationResolver) UpdateDebt(ctx context.Context, id uuid.UUID, input model.UpdateDebtInput) (*model.Debt, error) {
	debt, err := r.Services.Debt.GetByID(id)
	if err != nil {
		return nil, err
	}
	personName := debt.PersonName
	if input.PersonName != nil {
		personName = *input.PersonName
	}
	actualAmount := debt.ActualAmount
	if input.ActualAmount != nil {
		actualAmount = int64(*input.ActualAmount)
	}
	loanAmount := debt.LoanAmount
	if input.LoanAmount != nil {
		v := int64(*input.LoanAmount)
		loanAmount = &v
	}
	paymentType := debt.PaymentType
	if input.PaymentType != nil {
		paymentType = models.DebtPaymentType(*input.PaymentType)
	}
	monthlyPayment := debt.MonthlyPayment
	if input.MonthlyPayment != nil {
		v := int64(*input.MonthlyPayment)
		monthlyPayment = &v
	}
	tenor := debt.Tenor
	if input.Tenor != nil {
		tenor = input.Tenor
	}
	dueDate := debt.DueDate
	if input.DueDate != nil {
		dueDate = input.DueDate
	}
	var status *models.DebtStatus
	if input.Status != nil {
		s := models.DebtStatus(*input.Status)
		status = &s
	}
	updated, err := r.Services.Debt.Update(id, services.CreateDebtInput{
		PersonName:     personName,
		ActualAmount:   actualAmount,
		LoanAmount:     loanAmount,
		PaymentType:    paymentType,
		MonthlyPayment: monthlyPayment,
		Tenor:          tenor,
		DueDate:        dueDate,
		Notes:          input.Notes,
	}, status)
	if err != nil {
		return nil, err
	}
	return debtToModel(updated), nil
}

// DeleteDebt is the resolver for the deleteDebt field.
func (r *mutationResolver) DeleteDebt(ctx context.Context, id uuid.UUID) (bool, error) {
	err := r.Services.Debt.Delete(id)
	return err == nil, err
}

// RecordDebtPayment is the resolver for the recordDebtPayment field.
func (r *mutationResolver) RecordDebtPayment(ctx context.Context, input model.RecordDebtPaymentInput) (*model.DebtPayment, error) {
	payment, err := r.Services.Debt.RecordPayment(input.DebtID, int64(input.Amount), input.PaidAt)
	if err != nil {
		return nil, err
	}
	return debtPaymentToModel(payment), nil
}

// MarkDebtComplete is the resolver for the markDebtComplete field.
func (r *mutationResolver) MarkDebtComplete(ctx context.Context, id uuid.UUID) (*model.Debt, error) {
	debt, err := r.Services.Debt.MarkComplete(id)
	if err != nil {
		return nil, err
	}
	return debtToModel(debt), nil
}

// CreateIncomeCategory is the resolver for the createIncomeCategory field.
func (r *mutationResolver) CreateIncomeCategory(ctx context.Context, input model.CreateIncomeCategoryInput) (*model.IncomeCategory, error) {
	userID, ok := middleware.GetUserID(ctx)
	if !ok {
		return nil, utils.ErrUnauthorized
	}
	cat, err := r.Services.IncomeCategory.Create(userID, input.Name)
	if err != nil {
		return nil, err
	}
	return incomeCategoryToModel(cat), nil
}

// UpdateIncomeCategory is the resolver for the updateIncomeCategory field.
func (r *mutationResolver) UpdateIncomeCategory(ctx context.Context, id uuid.UUID, input model.UpdateIncomeCategoryInput) (*model.IncomeCategory, error) {
	cat, err := r.Services.IncomeCategory.Update(id, input.Name)
	if err != nil {
		return nil, err
	}
	return incomeCategoryToModel(cat), nil
}

// DeleteIncomeCategory is the resolver for the deleteIncomeCategory field.
func (r *mutationResolver) DeleteIncomeCategory(ctx context.Context, id uuid.UUID) (bool, error) {
	err := r.Services.IncomeCategory.Delete(id)
	return err == nil, err
}

// CreateIncome is the resolver for the createIncome field.
func (r *mutationResolver) CreateIncome(ctx context.Context, input model.CreateIncomeInput) (*model.Income, error) {
	userID, ok := middleware.GetUserID(ctx)
	if !ok {
		return nil, utils.ErrUnauthorized
	}
	isRecurring := false
	if input.IsRecurring != nil {
		isRecurring = *input.IsRecurring
	}
	inc, err := r.Services.Income.Create(userID, services.CreateIncomeInput{
		CategoryID:  input.CategoryID,
		SourceName:  input.SourceName,
		Amount:      int64(input.Amount),
		IncomeType:  models.IncomeType(input.IncomeType),
		IncomeDate:  input.IncomeDate,
		IsRecurring: isRecurring,
		Notes:       input.Notes,
	})
	if err != nil {
		return nil, err
	}
	return incomeToModel(inc), nil
}

// UpdateIncome is the resolver for the updateIncome field.
func (r *mutationResolver) UpdateIncome(ctx context.Context, id uuid.UUID, input model.UpdateIncomeInput) (*model.Income, error) {
	var amount *int64
	if input.Amount != nil {
		v := int64(*input.Amount)
		amount = &v
	}
	var incomeType *models.IncomeType
	if input.IncomeType != nil {
		v := models.IncomeType(*input.IncomeType)
		incomeType = &v
	}
	inc, err := r.Services.Income.Update(id, services.UpdateIncomeInput{
		CategoryID:  input.CategoryID,
		SourceName:  input.SourceName,
		Amount:      amount,
		IncomeType:  incomeType,
		IncomeDate:  input.IncomeDate,
		IsRecurring: input.IsRecurring,
		Notes:       input.Notes,
	})
	if err != nil {
		return nil, err
	}
	return incomeToModel(inc), nil
}

// DeleteIncome is the resolver for the deleteIncome field.
func (r *mutationResolver) DeleteIncome(ctx context.Context, id uuid.UUID) (bool, error) {
	err := r.Services.Income.Delete(id)
	return err == nil, err
}

// CreateRecurringIncome is the resolver for the createRecurringIncome field.
func (r *mutationResolver) CreateRecurringIncome(ctx context.Context, input model.CreateRecurringIncomeInput) (*model.RecurringIncome, error) {
	userID, ok := middleware.GetUserID(ctx)
	if !ok {
		return nil, utils.ErrUnauthorized
	}
	ri, err := r.Services.RecurringIncome.Create(userID, services.CreateRecurringIncomeInput{
		CategoryID:   input.CategoryID,
		SourceName:   input.SourceName,
		Amount:       int64(input.Amount),
		IncomeType:   models.IncomeType(input.IncomeType),
		RecurringDay: input.RecurringDay,
		Notes:        input.Notes,
	})
	if err != nil {
		return nil, err
	}
	return recurringIncomeToModel(ri), nil
}

// UpdateRecurringIncome is the resolver for the updateRecurringIncome field.
func (r *mutationResolver) UpdateRecurringIncome(ctx context.Context, id uuid.UUID, input model.UpdateRecurringIncomeInput) (*model.RecurringIncome, error) {
	var amount *int64
	if input.Amount != nil {
		v := int64(*input.Amount)
		amount = &v
	}
	var incomeType *models.IncomeType
	if input.IncomeType != nil {
		v := models.IncomeType(*input.IncomeType)
		incomeType = &v
	}
	ri, err := r.Services.RecurringIncome.Update(id, services.UpdateRecurringIncomeInput{
		CategoryID:   input.CategoryID,
		SourceName:   input.SourceName,
		Amount:       amount,
		IncomeType:   incomeType,
		RecurringDay: input.RecurringDay,
		IsActive:     input.IsActive,
		Notes:        input.Notes,
	})
	if err != nil {
		return nil, err
	}
	return recurringIncomeToModel(ri), nil
}

// DeleteRecurringIncome is the resolver for the deleteRecurringIncome field.
func (r *mutationResolver) DeleteRecurringIncome(ctx context.Context, id uuid.UUID) (bool, error) {
	err := r.Services.RecurringIncome.Delete(id)
	return err == nil, err
}

// CreateIncomeFromRecurring is the resolver for the createIncomeFromRecurring field.
func (r *mutationResolver) CreateIncomeFromRecurring(ctx context.Context, recurringID uuid.UUID, incomeDate *time.Time) (*model.Income, error) {
	userID, ok := middleware.GetUserID(ctx)
	if !ok {
		return nil, utils.ErrUnauthorized
	}
	inc, err := r.Services.RecurringIncome.CreateIncomeFromRecurring(userID, recurringID, incomeDate)
	if err != nil {
		return nil, err
	}
	return incomeToModel(inc), nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	userID, ok := middleware.GetUserID(ctx)
	if !ok {
		return nil, utils.ErrUnauthorized
	}
	user, err := r.Services.User.GetByID(userID)
	if err != nil {
		return nil, err
	}
	return userToModel(user), nil
}

// CheckEmailAvailability is the resolver for the checkEmailAvailability field.
func (r *queryResolver) CheckEmailAvailability(ctx context.Context, email string) (bool, error) {
	return r.Services.User.CheckEmailAvailability(email)
}

// Categories is the resolver for the categories field.
func (r *queryResolver) Categories(ctx context.Context) ([]*model.Category, error) {
	userID, ok := middleware.GetUserID(ctx)
	if !ok {
		return nil, utils.ErrUnauthorized
	}
	cats, err := r.Services.Category.GetByUserID(userID)
	if err != nil {
		return nil, err
	}
	result := make([]*model.Category, len(cats))
	for i, c := range cats {
		result[i] = categoryToModel(&c)
	}
	return result, nil
}

// Category is the resolver for the category field.
func (r *queryResolver) Category(ctx context.Context, id uuid.UUID) (*model.Category, error) {
	cat, err := r.Services.Category.GetByID(id)
	if err != nil {
		return nil, err
	}
	return categoryToModel(cat), nil
}

// Expenses is the resolver for the expenses field.
func (r *queryResolver) Expenses(ctx context.Context, filter *model.ExpenseFilter) ([]*model.Expense, error) {
	userID, ok := middleware.GetUserID(ctx)
	if !ok {
		return nil, utils.ErrUnauthorized
	}
	var repoFilter *repository.ExpenseFilter
	if filter != nil {
		repoFilter = &repository.ExpenseFilter{
			CategoryID: filter.CategoryID,
		}
		if filter.StartDate != nil {
			s := filter.StartDate.Format("2006-01-02")
			repoFilter.StartDate = &s
		}
		if filter.EndDate != nil {
			e := filter.EndDate.Format("2006-01-02")
			repoFilter.EndDate = &e
		}
	}
	exps, err := r.Services.Expense.GetByUserID(userID, repoFilter)
	if err != nil {
		return nil, err
	}
	result := make([]*model.Expense, len(exps))
	for i, e := range exps {
		result[i] = expenseToModel(&e)
	}
	return result, nil
}

// Expense is the resolver for the expense field.
func (r *queryResolver) Expense(ctx context.Context, id uuid.UUID) (*model.Expense, error) {
	exp, err := r.Services.Expense.GetByID(id)
	if err != nil {
		return nil, err
	}
	return expenseToModel(exp), nil
}

// ExpenseTemplates is the resolver for the expenseTemplates field.
func (r *queryResolver) ExpenseTemplates(ctx context.Context) ([]*model.ExpenseTemplate, error) {
	userID, ok := middleware.GetUserID(ctx)
	if !ok {
		return nil, utils.ErrUnauthorized
	}
	tmpls, err := r.Services.ExpenseTemplate.GetByUserID(userID)
	if err != nil {
		return nil, err
	}
	result := make([]*model.ExpenseTemplate, len(tmpls))
	for i, t := range tmpls {
		result[i] = expenseTemplateToModel(&t)
	}
	return result, nil
}

// ExpenseTemplate is the resolver for the expenseTemplate field.
func (r *queryResolver) ExpenseTemplate(ctx context.Context, id uuid.UUID) (*model.ExpenseTemplate, error) {
	tmpl, err := r.Services.ExpenseTemplate.GetByID(id)
	if err != nil {
		return nil, err
	}
	return expenseTemplateToModel(tmpl), nil
}

// Installments is the resolver for the installments field.
func (r *queryResolver) Installments(ctx context.Context, status *model.InstallmentStatus) ([]*model.Installment, error) {
	userID, ok := middleware.GetUserID(ctx)
	if !ok {
		return nil, utils.ErrUnauthorized
	}
	var s *models.InstallmentStatus
	if status != nil {
		st := models.InstallmentStatus(*status)
		s = &st
	}
	insts, err := r.Services.Installment.GetByUserID(userID, s)
	if err != nil {
		return nil, err
	}
	result := make([]*model.Installment, len(insts))
	for i, inst := range insts {
		result[i] = installmentToModel(&inst)
	}
	return result, nil
}

// Installment is the resolver for the installment field.
func (r *queryResolver) Installment(ctx context.Context, id uuid.UUID) (*model.Installment, error) {
	inst, err := r.Services.Installment.GetByID(id)
	if err != nil {
		return nil, err
	}
	return installmentToModel(inst), nil
}

// Debts is the resolver for the debts field.
func (r *queryResolver) Debts(ctx context.Context, status *model.DebtStatus) ([]*model.Debt, error) {
	userID, ok := middleware.GetUserID(ctx)
	if !ok {
		return nil, utils.ErrUnauthorized
	}
	var s *models.DebtStatus
	if status != nil {
		st := models.DebtStatus(*status)
		s = &st
	}
	debts, err := r.Services.Debt.GetByUserID(userID, s)
	if err != nil {
		return nil, err
	}
	result := make([]*model.Debt, len(debts))
	for i, d := range debts {
		result[i] = debtToModel(&d)
	}
	return result, nil
}

// Debt is the resolver for the debt field.
func (r *queryResolver) Debt(ctx context.Context, id uuid.UUID) (*model.Debt, error) {
	debt, err := r.Services.Debt.GetByID(id)
	if err != nil {
		return nil, err
	}
	return debtToModel(debt), nil
}

// IncomeCategories is the resolver for the incomeCategories field.
func (r *queryResolver) IncomeCategories(ctx context.Context) ([]*model.IncomeCategory, error) {
	userID, ok := middleware.GetUserID(ctx)
	if !ok {
		return nil, utils.ErrUnauthorized
	}
	cats, err := r.Services.IncomeCategory.GetByUserID(userID)
	if err != nil {
		return nil, err
	}
	result := make([]*model.IncomeCategory, len(cats))
	for i, c := range cats {
		result[i] = incomeCategoryToModel(&c)
	}
	return result, nil
}

// IncomeCategory is the resolver for the incomeCategory field.
func (r *queryResolver) IncomeCategory(ctx context.Context, id uuid.UUID) (*model.IncomeCategory, error) {
	cat, err := r.Services.IncomeCategory.GetByID(id)
	if err != nil {
		return nil, err
	}
	return incomeCategoryToModel(cat), nil
}

// Incomes is the resolver for the incomes field.
func (r *queryResolver) Incomes(ctx context.Context, filter *model.IncomeFilter) ([]*model.Income, error) {
	userID, ok := middleware.GetUserID(ctx)
	if !ok {
		return nil, utils.ErrUnauthorized
	}
	var repoFilter *repository.IncomeFilter
	if filter != nil {
		repoFilter = &repository.IncomeFilter{
			CategoryID: filter.CategoryID,
		}
		if filter.IncomeType != nil {
			v := models.IncomeType(*filter.IncomeType)
			repoFilter.IncomeType = &v
		}
		if filter.StartDate != nil {
			s := filter.StartDate.Format("2006-01-02")
			repoFilter.StartDate = &s
		}
		if filter.EndDate != nil {
			e := filter.EndDate.Format("2006-01-02")
			repoFilter.EndDate = &e
		}
	}
	incomes, err := r.Services.Income.GetByUserID(userID, repoFilter)
	if err != nil {
		return nil, err
	}
	result := make([]*model.Income, len(incomes))
	for i, inc := range incomes {
		result[i] = incomeToModel(&inc)
	}
	return result, nil
}

// Income is the resolver for the income field.
func (r *queryResolver) Income(ctx context.Context, id uuid.UUID) (*model.Income, error) {
	inc, err := r.Services.Income.GetByID(id)
	if err != nil {
		return nil, err
	}
	return incomeToModel(inc), nil
}

// RecurringIncomes is the resolver for the recurringIncomes field.
func (r *queryResolver) RecurringIncomes(ctx context.Context, isActive *bool) ([]*model.RecurringIncome, error) {
	userID, ok := middleware.GetUserID(ctx)
	if !ok {
		return nil, utils.ErrUnauthorized
	}
	ris, err := r.Services.RecurringIncome.GetByUserID(userID, isActive)
	if err != nil {
		return nil, err
	}
	result := make([]*model.RecurringIncome, len(ris))
	for i, ri := range ris {
		result[i] = recurringIncomeToModel(&ri)
	}
	return result, nil
}

// RecurringIncome is the resolver for the recurringIncome field.
func (r *queryResolver) RecurringIncome(ctx context.Context, id uuid.UUID) (*model.RecurringIncome, error) {
	ri, err := r.Services.RecurringIncome.GetByID(id)
	if err != nil {
		return nil, err
	}
	return recurringIncomeToModel(ri), nil
}

// Balance is the resolver for the balance field.
func (r *queryResolver) Balance(ctx context.Context, filter model.BalanceFilterInput) (*model.BalanceReport, error) {
	userID, ok := middleware.GetUserID(ctx)
	if !ok {
		return nil, utils.ErrUnauthorized
	}

	var startDate, endDate *time.Time
	if filter.StartDate != nil {
		startDate = filter.StartDate
	}
	if filter.EndDate != nil {
		endDate = filter.EndDate
	}

	report, err := r.Services.Balance.GetBalance(userID, services.BalanceFilterInput{
		Period:    services.BalancePeriod(filter.Period),
		StartDate: startDate,
		EndDate:   endDate,
	})
	if err != nil {
		return nil, err
	}

	return balanceReportToModel(report), nil
}

// Dashboard is the resolver for the dashboard field.
func (r *queryResolver) Dashboard(ctx context.Context) (*model.Dashboard, error) {
	userID, ok := middleware.GetUserID(ctx)
	if !ok {
		return nil, utils.ErrUnauthorized
	}
	dash, err := r.Services.Dashboard.GetDashboard(userID)
	if err != nil {
		return nil, err
	}
	return dashboardToModel(dash), nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//   - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//     it when you're done.
//   - You have helper methods in this file. Move them out to keep these resolver files clean.
func (r *mutationResolver) Resend2faCode(ctx context.Context, tempToken string) (bool, error) {
	if err := r.Services.Auth.Resend2FACode(ctx, tempToken); err != nil {
		return false, err
	}
	return true, nil
}
