package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"context"
	"time"

	"github.com/azzamdhx/moneybro/backend/internal/graph/model"
	"github.com/azzamdhx/moneybro/backend/internal/middleware"
	"github.com/azzamdhx/moneybro/backend/internal/models"
	"github.com/azzamdhx/moneybro/backend/internal/repository"
	"github.com/azzamdhx/moneybro/backend/internal/services"
	"github.com/azzamdhx/moneybro/backend/internal/utils"
	"github.com/google/uuid"
)

// Register is the resolver for the register field.
func (r *mutationResolver) Register(ctx context.Context, input model.RegisterInput) (*model.AuthPayload, error) {
	result, err := r.Services.Auth.Register(ctx, input.Email, input.Password, input.Name)
	if err != nil {
		return nil, err
	}

	return &model.AuthPayload{
		Requires2fa: true,
		TempToken:   &result.TempToken,
	}, nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input model.LoginInput) (*model.AuthPayload, error) {
	result, err := r.Services.Auth.Login(ctx, input.Email, input.Password)
	if err != nil {
		return nil, err
	}

	// If 2FA is required, return tempToken
	if result.Requires2FA {
		return &model.AuthPayload{
			Requires2fa: true,
			TempToken:   &result.TempToken,
		}, nil
	}

	return &model.AuthPayload{
		Token:       &result.Token,
		User:        userToModel(result.User),
		Requires2fa: false,
	}, nil
}

// VerifyRegistration is the resolver for the verifyRegistration field.
func (r *mutationResolver) VerifyRegistration(ctx context.Context, input model.Verify2FAInput) (*model.TwoFAPayload, error) {
	result, err := r.Services.Auth.VerifyRegistration(ctx, input.TempToken, input.Code)
	if err != nil {
		return nil, err
	}
	return &model.TwoFAPayload{
		Token: result.Token,
		User:  userToModel(result.User),
	}, nil
}

// Verify2fa is the resolver for the verify2FA field.
func (r *mutationResolver) Verify2fa(ctx context.Context, input model.Verify2FAInput) (*model.TwoFAPayload, error) {
	result, err := r.Services.Auth.Verify2FA(ctx, input.TempToken, input.Code)
	if err != nil {
		return nil, err
	}
	return &model.TwoFAPayload{
		Token: result.Token,
		User:  userToModel(result.User),
	}, nil
}

// Resend2FACode is the resolver for the resend2FACode field.
func (r *mutationResolver) Resend2FACode(ctx context.Context, tempToken string) (bool, error) {
	if err := r.Services.Auth.Resend2FACode(ctx, tempToken); err != nil {
		return false, err
	}
	return true, nil
}

// Enable2fa is the resolver for the enable2FA field.
func (r *mutationResolver) Enable2fa(ctx context.Context, password string) (bool, error) {
	userID, ok := middleware.GetUserID(ctx)
	if !ok {
		return false, utils.ErrUnauthorized
	}
	if err := r.Services.Auth.Enable2FA(userID, password); err != nil {
		return false, err
	}
	return true, nil
}

// Disable2fa is the resolver for the disable2FA field.
func (r *mutationResolver) Disable2fa(ctx context.Context, password string) (bool, error) {
	userID, ok := middleware.GetUserID(ctx)
	if !ok {
		return false, utils.ErrUnauthorized
	}
	if err := r.Services.Auth.Disable2FA(userID, password); err != nil {
		return false, err
	}
	return true, nil
}

// UpdateProfile is the resolver for the updateProfile field.
func (r *mutationResolver) UpdateProfile(ctx context.Context, input model.UpdateProfileInput) (*model.User, error) {
	userID, ok := middleware.GetUserID(ctx)
	if !ok {
		return nil, utils.ErrUnauthorized
	}
	user, err := r.Services.User.UpdateProfile(userID, input.Name, input.Email, input.ProfileImage, input.CurrentPassword, input.Password)
	if err != nil {
		return nil, err
	}
	return userToModel(user), nil
}

// UpdateNotificationSettings is the resolver for the updateNotificationSettings field.
func (r *mutationResolver) UpdateNotificationSettings(ctx context.Context, input model.UpdateNotificationSettingsInput) (*model.User, error) {
	userID, ok := middleware.GetUserID(ctx)
	if !ok {
		return nil, utils.ErrUnauthorized
	}
	user, err := r.Services.User.UpdateNotificationSettings(userID, input.NotifyInstallment, input.NotifyDebt, input.NotifySavingsGoal, input.NotifyDaysBefore)
	if err != nil {
		return nil, err
	}
	return userToModel(user), nil
}

// DeleteAccount is the resolver for the deleteAccount field.
func (r *mutationResolver) DeleteAccount(ctx context.Context, input model.DeleteAccountInput) (bool, error) {
	userID, ok := middleware.GetUserID(ctx)
	if !ok {
		return false, utils.ErrUnauthorized
	}
	if err := r.Services.User.DeleteAccount(userID, input.Password); err != nil {
		return false, err
	}
	return true, nil
}

// ForgotPassword is the resolver for the forgotPassword field.
func (r *mutationResolver) ForgotPassword(ctx context.Context, input model.ForgotPasswordInput) (bool, error) {
	if err := r.Services.Auth.ForgotPassword(ctx, input.Email); err != nil {
		return false, err
	}
	return true, nil
}

// ResetPassword is the resolver for the resetPassword field.
func (r *mutationResolver) ResetPassword(ctx context.Context, input model.ResetPasswordInput) (bool, error) {
	if err := r.Services.Auth.ResetPassword(input.Token, input.Password); err != nil {
		return false, err
	}
	return true, nil
}

// CreateCategory is the resolver for the createCategory field.
func (r *mutationResolver) CreateCategory(ctx context.Context, input model.CreateCategoryInput) (*model.Category, error) {
	userID, ok := middleware.GetUserID(ctx)
	if !ok {
		return nil, utils.ErrUnauthorized
	}
	cat, err := r.Services.Category.Create(userID, input.Name)
	if err != nil {
		return nil, err
	}
	return categoryToModel(cat), nil
}

// UpdateCategory is the resolver for the updateCategory field.
func (r *mutationResolver) UpdateCategory(ctx context.Context, id uuid.UUID, input model.UpdateCategoryInput) (*model.Category, error) {
	cat, err := r.Services.Category.Update(id, input.Name)
	if err != nil {
		return nil, err
	}
	return categoryToModel(cat), nil
}

// DeleteCategory is the resolver for the deleteCategory field.
func (r *mutationResolver) DeleteCategory(ctx context.Context, id uuid.UUID) (bool, error) {
	err := r.Services.Category.Delete(id)
	return err == nil, err
}

// CreateExpense is the resolver for the createExpense field.
func (r *mutationResolver) CreateExpense(ctx context.Context, input model.CreateExpenseInput) (*model.Expense, error) {
	userID, ok := middleware.GetUserID(ctx)
	if !ok {
		return nil, utils.ErrUnauthorized
	}
	exp, err := r.Services.Expense.Create(userID, services.CreateExpenseInput{
		CategoryID:  input.CategoryID,
		ItemName:    input.ItemName,
		UnitPrice:   int64(input.UnitPrice),
		Quantity:    input.Quantity,
		Notes:       input.Notes,
		ExpenseDate: input.ExpenseDate,
	})
	if err != nil {
		return nil, err
	}
	return expenseToModel(exp), nil
}

// UpdateExpense is the resolver for the updateExpense field.
func (r *mutationResolver) UpdateExpense(ctx context.Context, id uuid.UUID, input model.UpdateExpenseInput) (*model.Expense, error) {
	var unitPrice *int64
	if input.UnitPrice != nil {
		v := int64(*input.UnitPrice)
		unitPrice = &v
	}
	exp, err := r.Services.Expense.Update(id, services.UpdateExpenseInput{
		CategoryID:  input.CategoryID,
		ItemName:    input.ItemName,
		UnitPrice:   unitPrice,
		Quantity:    input.Quantity,
		Notes:       input.Notes,
		ExpenseDate: input.ExpenseDate,
	})
	if err != nil {
		return nil, err
	}
	return expenseToModel(exp), nil
}

// DeleteExpense is the resolver for the deleteExpense field.
func (r *mutationResolver) DeleteExpense(ctx context.Context, id uuid.UUID) (bool, error) {
	err := r.Services.Expense.Delete(id)
	return err == nil, err
}

// CreateExpenseTemplateGroup is the resolver for the createExpenseTemplateGroup field.
func (r *mutationResolver) CreateExpenseTemplateGroup(ctx context.Context, input model.CreateExpenseTemplateGroupInput) (*model.ExpenseTemplateGroup, error) {
	userID, ok := middleware.GetUserID(ctx)
	if !ok {
		return nil, utils.ErrUnauthorized
	}
	items := make([]services.CreateExpenseTemplateItemInput, len(input.Items))
	for i, item := range input.Items {
		items[i] = services.CreateExpenseTemplateItemInput{
			CategoryID: item.CategoryID,
			ItemName:   item.ItemName,
			UnitPrice:  int64(item.UnitPrice),
			Quantity:   item.Quantity,
		}
	}
	group, err := r.Services.ExpenseTemplateGroup.Create(userID, services.CreateExpenseTemplateGroupInput{
		Name:         input.Name,
		RecurringDay: input.RecurringDay,
		Notes:        input.Notes,
		Items:        items,
	})
	if err != nil {
		return nil, err
	}
	return expenseTemplateGroupToModel(group), nil
}

// UpdateExpenseTemplateGroup is the resolver for the updateExpenseTemplateGroup field.
func (r *mutationResolver) UpdateExpenseTemplateGroup(ctx context.Context, id uuid.UUID, input model.UpdateExpenseTemplateGroupInput) (*model.ExpenseTemplateGroup, error) {
	group, err := r.Services.ExpenseTemplateGroup.Update(id, services.UpdateExpenseTemplateGroupInput{
		Name:         input.Name,
		RecurringDay: input.RecurringDay,
		Notes:        input.Notes,
	})
	if err != nil {
		return nil, err
	}
	return expenseTemplateGroupToModel(group), nil
}

// DeleteExpenseTemplateGroup is the resolver for the deleteExpenseTemplateGroup field.
func (r *mutationResolver) DeleteExpenseTemplateGroup(ctx context.Context, id uuid.UUID) (bool, error) {
	err := r.Services.ExpenseTemplateGroup.Delete(id)
	return err == nil, err
}

// AddExpenseTemplateItem is the resolver for the addExpenseTemplateItem field.
func (r *mutationResolver) AddExpenseTemplateItem(ctx context.Context, groupID uuid.UUID, input model.CreateExpenseTemplateItemInput) (*model.ExpenseTemplateGroup, error) {
	group, err := r.Services.ExpenseTemplateGroup.AddItem(groupID, services.CreateExpenseTemplateItemInput{
		CategoryID: input.CategoryID,
		ItemName:   input.ItemName,
		UnitPrice:  int64(input.UnitPrice),
		Quantity:   input.Quantity,
	})
	if err != nil {
		return nil, err
	}
	return expenseTemplateGroupToModel(group), nil
}

// UpdateExpenseTemplateItem is the resolver for the updateExpenseTemplateItem field.
func (r *mutationResolver) UpdateExpenseTemplateItem(ctx context.Context, itemID uuid.UUID, input model.UpdateExpenseTemplateItemInput) (*model.ExpenseTemplateItem, error) {
	var unitPrice *int64
	if input.UnitPrice != nil {
		v := int64(*input.UnitPrice)
		unitPrice = &v
	}
	item, err := r.Services.ExpenseTemplateGroup.UpdateItem(itemID, services.UpdateExpenseTemplateItemInput{
		CategoryID: input.CategoryID,
		ItemName:   input.ItemName,
		UnitPrice:  unitPrice,
		Quantity:   input.Quantity,
	})
	if err != nil {
		return nil, err
	}
	return expenseTemplateItemToModel(item), nil
}

// DeleteExpenseTemplateItem is the resolver for the deleteExpenseTemplateItem field.
func (r *mutationResolver) DeleteExpenseTemplateItem(ctx context.Context, itemID uuid.UUID) (bool, error) {
	err := r.Services.ExpenseTemplateGroup.DeleteItem(itemID)
	return err == nil, err
}

// CreateExpensesFromTemplateGroup is the resolver for the createExpensesFromTemplateGroup field.
func (r *mutationResolver) CreateExpensesFromTemplateGroup(ctx context.Context, groupID uuid.UUID, expenseDate *time.Time) ([]*model.Expense, error) {
	userID, ok := middleware.GetUserID(ctx)
	if !ok {
		return nil, utils.ErrUnauthorized
	}
	expenses, err := r.Services.ExpenseTemplateGroup.CreateExpensesFromGroup(userID, groupID, expenseDate)
	if err != nil {
		return nil, err
	}
	result := make([]*model.Expense, len(expenses))
	for i, exp := range expenses {
		result[i] = expenseToModel(&exp)
	}
	return result, nil
}

// CreateInstallment is the resolver for the createInstallment field.
func (r *mutationResolver) CreateInstallment(ctx context.Context, input model.CreateInstallmentInput) (*model.Installment, error) {
	userID, ok := middleware.GetUserID(ctx)
	if !ok {
		return nil, utils.ErrUnauthorized
	}
	inst, err := r.Services.Installment.Create(userID, services.CreateInstallmentInput{
		Name:           input.Name,
		ActualAmount:   int64(input.ActualAmount),
		LoanAmount:     int64(input.LoanAmount),
		MonthlyPayment: int64(input.MonthlyPayment),
		Tenor:          input.Tenor,
		StartDate:      input.StartDate,
		DueDay:         input.DueDay,
		Notes:          input.Notes,
	})
	if err != nil {
		return nil, err
	}
	return installmentToModel(inst), nil
}

// UpdateInstallment is the resolver for the updateInstallment field.
func (r *mutationResolver) UpdateInstallment(ctx context.Context, id uuid.UUID, input model.UpdateInstallmentInput) (*model.Installment, error) {
	inst, err := r.Services.Installment.GetByID(id)
	if err != nil {
		return nil, err
	}
	name := inst.Name
	if input.Name != nil {
		name = *input.Name
	}
	actualAmount := inst.ActualAmount
	if input.ActualAmount != nil {
		actualAmount = int64(*input.ActualAmount)
	}
	loanAmount := inst.LoanAmount
	if input.LoanAmount != nil {
		loanAmount = int64(*input.LoanAmount)
	}
	monthlyPayment := inst.MonthlyPayment
	if input.MonthlyPayment != nil {
		monthlyPayment = int64(*input.MonthlyPayment)
	}
	tenor := inst.Tenor
	if input.Tenor != nil {
		tenor = *input.Tenor
	}
	startDate := inst.StartDate
	if input.StartDate != nil {
		startDate = *input.StartDate
	}
	dueDay := inst.DueDay
	if input.DueDay != nil {
		dueDay = *input.DueDay
	}
	var status *models.InstallmentStatus
	if input.Status != nil {
		s := models.InstallmentStatus(*input.Status)
		status = &s
	}
	updated, err := r.Services.Installment.Update(id, services.CreateInstallmentInput{
		Name:           name,
		ActualAmount:   actualAmount,
		LoanAmount:     loanAmount,
		MonthlyPayment: monthlyPayment,
		Tenor:          tenor,
		StartDate:      startDate,
		DueDay:         dueDay,
		Notes:          input.Notes,
	}, status)
	if err != nil {
		return nil, err
	}
	return installmentToModel(updated), nil
}

// DeleteInstallment is the resolver for the deleteInstallment field.
func (r *mutationResolver) DeleteInstallment(ctx context.Context, id uuid.UUID) (bool, error) {
	err := r.Services.Installment.Delete(id)
	return err == nil, err
}

// RecordInstallmentPayment is the resolver for the recordInstallmentPayment field.
func (r *mutationResolver) RecordInstallmentPayment(ctx context.Context, input model.RecordInstallmentPaymentInput) (*model.InstallmentPayment, error) {
	payment, err := r.Services.Installment.RecordPayment(input.InstallmentID, int64(input.Amount), input.PaidAt)
	if err != nil {
		return nil, err
	}
	return installmentPaymentToModel(payment), nil
}

// MarkInstallmentComplete is the resolver for the markInstallmentComplete field.
func (r *mutationResolver) MarkInstallmentComplete(ctx context.Context, id uuid.UUID) (*model.Installment, error) {
	installment, err := r.Services.Installment.MarkComplete(id)
	if err != nil {
		return nil, err
	}
	return installmentToModel(installment), nil
}

// CreateDebt is the resolver for the createDebt field.
func (r *mutationResolver) CreateDebt(ctx context.Context, input model.CreateDebtInput) (*model.Debt, error) {
	userID, ok := middleware.GetUserID(ctx)
	if !ok {
		return nil, utils.ErrUnauthorized
	}
	var loanAmount *int64
	if input.LoanAmount != nil {
		v := int64(*input.LoanAmount)
		loanAmount = &v
	}
	var monthlyPayment *int64
	if input.MonthlyPayment != nil {
		v := int64(*input.MonthlyPayment)
		monthlyPayment = &v
	}
	debt, err := r.Services.Debt.Create(userID, services.CreateDebtInput{
		PersonName:     input.PersonName,
		ActualAmount:   int64(input.ActualAmount),
		LoanAmount:     loanAmount,
		PaymentType:    models.DebtPaymentType(input.PaymentType),
		MonthlyPayment: monthlyPayment,
		Tenor:          input.Tenor,
		DueDate:        input.DueDate,
		Notes:          input.Notes,
	})
	if err != nil {
		return nil, err
	}
	return debtToModel(debt), nil
}

// UpdateDebt is the resolver for the updateDebt field.
func (r *mutationResolver) UpdateDebt(ctx context.Context, id uuid.UUID, input model.UpdateDebtInput) (*model.Debt, error) {
	debt, err := r.Services.Debt.GetByID(id)
	if err != nil {
		return nil, err
	}
	personName := debt.PersonName
	if input.PersonName != nil {
		personName = *input.PersonName
	}
	actualAmount := debt.ActualAmount
	if input.ActualAmount != nil {
		actualAmount = int64(*input.ActualAmount)
	}
	loanAmount := debt.LoanAmount
	if input.LoanAmount != nil {
		v := int64(*input.LoanAmount)
		loanAmount = &v
	}
	paymentType := debt.PaymentType
	if input.PaymentType != nil {
		paymentType = models.DebtPaymentType(*input.PaymentType)
	}
	monthlyPayment := debt.MonthlyPayment
	if input.MonthlyPayment != nil {
		v := int64(*input.MonthlyPayment)
		monthlyPayment = &v
	}
	tenor := debt.Tenor
	if input.Tenor != nil {
		tenor = input.Tenor
	}
	dueDate := debt.DueDate
	if input.DueDate != nil {
		dueDate = input.DueDate
	}
	var status *models.DebtStatus
	if input.Status != nil {
		s := models.DebtStatus(*input.Status)
		status = &s
	}
	updated, err := r.Services.Debt.Update(id, services.CreateDebtInput{
		PersonName:     personName,
		ActualAmount:   actualAmount,
		LoanAmount:     loanAmount,
		PaymentType:    paymentType,
		MonthlyPayment: monthlyPayment,
		Tenor:          tenor,
		DueDate:        dueDate,
		Notes:          input.Notes,
	}, status)
	if err != nil {
		return nil, err
	}
	return debtToModel(updated), nil
}

// DeleteDebt is the resolver for the deleteDebt field.
func (r *mutationResolver) DeleteDebt(ctx context.Context, id uuid.UUID) (bool, error) {
	err := r.Services.Debt.Delete(id)
	return err == nil, err
}

// RecordDebtPayment is the resolver for the recordDebtPayment field.
func (r *mutationResolver) RecordDebtPayment(ctx context.Context, input model.RecordDebtPaymentInput) (*model.DebtPayment, error) {
	payment, err := r.Services.Debt.RecordPayment(input.DebtID, int64(input.Amount), input.PaidAt)
	if err != nil {
		return nil, err
	}
	return debtPaymentToModel(payment), nil
}

// MarkDebtComplete is the resolver for the markDebtComplete field.
func (r *mutationResolver) MarkDebtComplete(ctx context.Context, id uuid.UUID) (*model.Debt, error) {
	debt, err := r.Services.Debt.MarkComplete(id)
	if err != nil {
		return nil, err
	}
	return debtToModel(debt), nil
}

// CreateIncomeCategory is the resolver for the createIncomeCategory field.
func (r *mutationResolver) CreateIncomeCategory(ctx context.Context, input model.CreateIncomeCategoryInput) (*model.IncomeCategory, error) {
	userID, ok := middleware.GetUserID(ctx)
	if !ok {
		return nil, utils.ErrUnauthorized
	}
	cat, err := r.Services.IncomeCategory.Create(userID, input.Name)
	if err != nil {
		return nil, err
	}
	return incomeCategoryToModel(cat), nil
}

// UpdateIncomeCategory is the resolver for the updateIncomeCategory field.
func (r *mutationResolver) UpdateIncomeCategory(ctx context.Context, id uuid.UUID, input model.UpdateIncomeCategoryInput) (*model.IncomeCategory, error) {
	cat, err := r.Services.IncomeCategory.Update(id, input.Name)
	if err != nil {
		return nil, err
	}
	return incomeCategoryToModel(cat), nil
}

// DeleteIncomeCategory is the resolver for the deleteIncomeCategory field.
func (r *mutationResolver) DeleteIncomeCategory(ctx context.Context, id uuid.UUID) (bool, error) {
	err := r.Services.IncomeCategory.Delete(id)
	return err == nil, err
}

// CreateIncome is the resolver for the createIncome field.
func (r *mutationResolver) CreateIncome(ctx context.Context, input model.CreateIncomeInput) (*model.Income, error) {
	userID, ok := middleware.GetUserID(ctx)
	if !ok {
		return nil, utils.ErrUnauthorized
	}
	isRecurring := false
	if input.IsRecurring != nil {
		isRecurring = *input.IsRecurring
	}
	inc, err := r.Services.Income.Create(userID, services.CreateIncomeInput{
		CategoryID:  input.CategoryID,
		SourceName:  input.SourceName,
		Amount:      int64(input.Amount),
		IncomeType:  models.IncomeType(input.IncomeType),
		IncomeDate:  input.IncomeDate,
		IsRecurring: isRecurring,
		Notes:       input.Notes,
	})
	if err != nil {
		return nil, err
	}
	return incomeToModel(inc), nil
}

// UpdateIncome is the resolver for the updateIncome field.
func (r *mutationResolver) UpdateIncome(ctx context.Context, id uuid.UUID, input model.UpdateIncomeInput) (*model.Income, error) {
	var amount *int64
	if input.Amount != nil {
		v := int64(*input.Amount)
		amount = &v
	}
	var incomeType *models.IncomeType
	if input.IncomeType != nil {
		v := models.IncomeType(*input.IncomeType)
		incomeType = &v
	}
	inc, err := r.Services.Income.Update(id, services.UpdateIncomeInput{
		CategoryID:  input.CategoryID,
		SourceName:  input.SourceName,
		Amount:      amount,
		IncomeType:  incomeType,
		IncomeDate:  input.IncomeDate,
		IsRecurring: input.IsRecurring,
		Notes:       input.Notes,
	})
	if err != nil {
		return nil, err
	}
	return incomeToModel(inc), nil
}

// DeleteIncome is the resolver for the deleteIncome field.
func (r *mutationResolver) DeleteIncome(ctx context.Context, id uuid.UUID) (bool, error) {
	err := r.Services.Income.Delete(id)
	return err == nil, err
}

// CreateRecurringIncome is the resolver for the createRecurringIncome field.
func (r *mutationResolver) CreateRecurringIncome(ctx context.Context, input model.CreateRecurringIncomeInput) (*model.RecurringIncome, error) {
	userID, ok := middleware.GetUserID(ctx)
	if !ok {
		return nil, utils.ErrUnauthorized
	}
	ri, err := r.Services.RecurringIncome.Create(userID, services.CreateRecurringIncomeInput{
		CategoryID:   input.CategoryID,
		SourceName:   input.SourceName,
		Amount:       int64(input.Amount),
		IncomeType:   models.IncomeType(input.IncomeType),
		RecurringDay: input.RecurringDay,
		Notes:        input.Notes,
	})
	if err != nil {
		return nil, err
	}
	return recurringIncomeToModel(ri), nil
}

// UpdateRecurringIncome is the resolver for the updateRecurringIncome field.
func (r *mutationResolver) UpdateRecurringIncome(ctx context.Context, id uuid.UUID, input model.UpdateRecurringIncomeInput) (*model.RecurringIncome, error) {
	var amount *int64
	if input.Amount != nil {
		v := int64(*input.Amount)
		amount = &v
	}
	var incomeType *models.IncomeType
	if input.IncomeType != nil {
		v := models.IncomeType(*input.IncomeType)
		incomeType = &v
	}
	ri, err := r.Services.RecurringIncome.Update(id, services.UpdateRecurringIncomeInput{
		CategoryID:   input.CategoryID,
		SourceName:   input.SourceName,
		Amount:       amount,
		IncomeType:   incomeType,
		RecurringDay: input.RecurringDay,
		IsActive:     input.IsActive,
		Notes:        input.Notes,
	})
	if err != nil {
		return nil, err
	}
	return recurringIncomeToModel(ri), nil
}

// DeleteRecurringIncome is the resolver for the deleteRecurringIncome field.
func (r *mutationResolver) DeleteRecurringIncome(ctx context.Context, id uuid.UUID) (bool, error) {
	err := r.Services.RecurringIncome.Delete(id)
	return err == nil, err
}

// CreateIncomeFromRecurring is the resolver for the createIncomeFromRecurring field.
func (r *mutationResolver) CreateIncomeFromRecurring(ctx context.Context, recurringID uuid.UUID, incomeDate *time.Time) (*model.Income, error) {
	userID, ok := middleware.GetUserID(ctx)
	if !ok {
		return nil, utils.ErrUnauthorized
	}
	inc, err := r.Services.RecurringIncome.CreateIncomeFromRecurring(userID, recurringID, incomeDate)
	if err != nil {
		return nil, err
	}
	return incomeToModel(inc), nil
}

// CreateSavingsGoal is the resolver for the createSavingsGoal field.
func (r *mutationResolver) CreateSavingsGoal(ctx context.Context, input model.CreateSavingsGoalInput) (*model.SavingsGoal, error) {
	userID, ok := middleware.GetUserID(ctx)
	if !ok {
		return nil, utils.ErrUnauthorized
	}

	goal, err := r.Services.SavingsGoal.Create(userID, services.CreateSavingsGoalInput{
		Name:         input.Name,
		TargetAmount: int64(input.TargetAmount),
		TargetDate:   input.TargetDate,
		Icon:         input.Icon,
		Notes:        input.Notes,
	})
	if err != nil {
		return nil, err
	}

	return savingsGoalToModel(goal), nil
}

// UpdateSavingsGoal is the resolver for the updateSavingsGoal field.
func (r *mutationResolver) UpdateSavingsGoal(ctx context.Context, id uuid.UUID, input model.UpdateSavingsGoalInput) (*model.SavingsGoal, error) {
	svcInput := services.UpdateSavingsGoalInput{
		Name:  input.Name,
		Icon:  input.Icon,
		Notes: input.Notes,
	}
	if input.TargetAmount != nil {
		v := int64(*input.TargetAmount)
		svcInput.TargetAmount = &v
	}
	if input.TargetDate != nil {
		svcInput.TargetDate = input.TargetDate
	}
	if input.Status != nil {
		s := models.SavingsGoalStatus(*input.Status)
		svcInput.Status = &s
	}

	goal, err := r.Services.SavingsGoal.Update(id, svcInput)
	if err != nil {
		return nil, err
	}

	return savingsGoalToModel(goal), nil
}

// DeleteSavingsGoal is the resolver for the deleteSavingsGoal field.
func (r *mutationResolver) DeleteSavingsGoal(ctx context.Context, id uuid.UUID) (bool, error) {
	err := r.Services.SavingsGoal.Delete(id)
	return err == nil, err
}

// AddSavingsContribution is the resolver for the addSavingsContribution field.
func (r *mutationResolver) AddSavingsContribution(ctx context.Context, input model.AddSavingsContributionInput) (*model.SavingsContribution, error) {
	contribution, err := r.Services.SavingsGoal.AddContribution(input.SavingsGoalID, int64(input.Amount), input.ContributionDate, input.Notes)
	if err != nil {
		return nil, err
	}
	return savingsContributionToModel(contribution), nil
}

// WithdrawSavingsContribution is the resolver for the withdrawSavingsContribution field.
func (r *mutationResolver) WithdrawSavingsContribution(ctx context.Context, id uuid.UUID) (bool, error) {
	err := r.Services.SavingsGoal.WithdrawContribution(id)
	return err == nil, err
}

// MarkSavingsGoalComplete is the resolver for the markSavingsGoalComplete field.
func (r *mutationResolver) MarkSavingsGoalComplete(ctx context.Context, id uuid.UUID) (*model.SavingsGoal, error) {
	goal, err := r.Services.SavingsGoal.MarkComplete(id)
	if err != nil {
		return nil, err
	}
	return savingsGoalToModel(goal), nil
}

// CreateWalletAccount is the resolver for the createWalletAccount field.
func (r *mutationResolver) CreateWalletAccount(ctx context.Context, input model.CreateAccountInput) (*model.Account, error) {
	userID, ok := middleware.GetUserID(ctx)
	if !ok {
		return nil, utils.ErrUnauthorized
	}
	acc, err := r.Services.Account.CreateAccount(userID, input.Name, models.AccountType(input.AccountType), false)
	if err != nil {
		return nil, err
	}
	return accountToModel(acc), nil
}

// UpdateWalletAccount is the resolver for the updateWalletAccount field.
func (r *mutationResolver) UpdateWalletAccount(ctx context.Context, id uuid.UUID, input model.UpdateAccountInput) (*model.Account, error) {
	_, ok := middleware.GetUserID(ctx)
	if !ok {
		return nil, utils.ErrUnauthorized
	}
	acc, err := r.Services.Account.UpdateAccount(id, input.Name)
	if err != nil {
		return nil, err
	}
	return accountToModel(acc), nil
}

// DeleteWalletAccount is the resolver for the deleteWalletAccount field.
func (r *mutationResolver) DeleteWalletAccount(ctx context.Context, id uuid.UUID) (bool, error) {
	_, ok := middleware.GetUserID(ctx)
	if !ok {
		return false, utils.ErrUnauthorized
	}
	if err := r.Services.Account.DeleteAccount(id); err != nil {
		return false, err
	}
	return true, nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	userID, ok := middleware.GetUserID(ctx)
	if !ok {
		return nil, utils.ErrUnauthorized
	}
	user, err := r.Services.User.GetByID(userID)
	if err != nil {
		return nil, err
	}
	return userToModel(user), nil
}

// CheckEmailAvailability is the resolver for the checkEmailAvailability field.
func (r *queryResolver) CheckEmailAvailability(ctx context.Context, email string) (bool, error) {
	return r.Services.User.CheckEmailAvailability(email)
}

// Categories is the resolver for the categories field.
func (r *queryResolver) Categories(ctx context.Context) ([]*model.Category, error) {
	userID, ok := middleware.GetUserID(ctx)
	if !ok {
		return nil, utils.ErrUnauthorized
	}
	cats, err := r.Services.Category.GetByUserID(userID)
	if err != nil {
		return nil, err
	}
	result := make([]*model.Category, len(cats))
	for i, c := range cats {
		result[i] = categoryToModel(&c)
	}
	return result, nil
}

// Category is the resolver for the category field.
func (r *queryResolver) Category(ctx context.Context, id uuid.UUID) (*model.Category, error) {
	cat, err := r.Services.Category.GetByID(id)
	if err != nil {
		return nil, err
	}
	return categoryToModel(cat), nil
}

// Expenses is the resolver for the expenses field.
func (r *queryResolver) Expenses(ctx context.Context, filter *model.ExpenseFilter) (*model.ExpensesWithSummary, error) {
	userID, ok := middleware.GetUserID(ctx)
	if !ok {
		return nil, utils.ErrUnauthorized
	}
	var repoFilter *repository.ExpenseFilter
	if filter != nil {
		repoFilter = &repository.ExpenseFilter{
			CategoryID: filter.CategoryID,
		}
		if filter.StartDate != nil {
			s := filter.StartDate.Format("2006-01-02")
			repoFilter.StartDate = &s
		}
		if filter.EndDate != nil {
			e := filter.EndDate.Format("2006-01-02")
			repoFilter.EndDate = &e
		}
	}
	exps, err := r.Services.Expense.GetByUserID(userID, repoFilter)
	if err != nil {
		return nil, err
	}

	// Convert to model
	items := make([]*model.Expense, len(exps))
	for i, e := range exps {
		items[i] = expenseToModel(&e)
	}

	// Calculate summary
	summary := calculateExpenseSummary(exps)

	return &model.ExpensesWithSummary{
		Items:   items,
		Summary: summary,
	}, nil
}

// Expense is the resolver for the expense field.
func (r *queryResolver) Expense(ctx context.Context, id uuid.UUID) (*model.Expense, error) {
	exp, err := r.Services.Expense.GetByID(id)
	if err != nil {
		return nil, err
	}
	return expenseToModel(exp), nil
}

// ExpenseTemplateGroups is the resolver for the expenseTemplateGroups field.
func (r *queryResolver) ExpenseTemplateGroups(ctx context.Context) ([]*model.ExpenseTemplateGroup, error) {
	userID, ok := middleware.GetUserID(ctx)
	if !ok {
		return nil, utils.ErrUnauthorized
	}
	groups, err := r.Services.ExpenseTemplateGroup.GetByUserID(userID)
	if err != nil {
		return nil, err
	}
	result := make([]*model.ExpenseTemplateGroup, len(groups))
	for i, g := range groups {
		result[i] = expenseTemplateGroupToModel(&g)
	}
	return result, nil
}

// ExpenseTemplateGroup is the resolver for the expenseTemplateGroup field.
func (r *queryResolver) ExpenseTemplateGroup(ctx context.Context, id uuid.UUID) (*model.ExpenseTemplateGroup, error) {
	group, err := r.Services.ExpenseTemplateGroup.GetByID(id)
	if err != nil {
		return nil, err
	}
	return expenseTemplateGroupToModel(group), nil
}

// Installments is the resolver for the installments field.
func (r *queryResolver) Installments(ctx context.Context, status *model.InstallmentStatus) ([]*model.Installment, error) {
	userID, ok := middleware.GetUserID(ctx)
	if !ok {
		return nil, utils.ErrUnauthorized
	}
	var s *models.InstallmentStatus
	if status != nil {
		st := models.InstallmentStatus(*status)
		s = &st
	}
	insts, err := r.Services.Installment.GetByUserID(userID, s)
	if err != nil {
		return nil, err
	}
	result := make([]*model.Installment, len(insts))
	for i, inst := range insts {
		result[i] = installmentToModel(&inst)
	}
	return result, nil
}

// Installment is the resolver for the installment field.
func (r *queryResolver) Installment(ctx context.Context, id uuid.UUID) (*model.Installment, error) {
	inst, err := r.Services.Installment.GetByID(id)
	if err != nil {
		return nil, err
	}
	return installmentToModel(inst), nil
}

// Debts is the resolver for the debts field.
func (r *queryResolver) Debts(ctx context.Context, status *model.DebtStatus) ([]*model.Debt, error) {
	userID, ok := middleware.GetUserID(ctx)
	if !ok {
		return nil, utils.ErrUnauthorized
	}
	var s *models.DebtStatus
	if status != nil {
		st := models.DebtStatus(*status)
		s = &st
	}
	debts, err := r.Services.Debt.GetByUserID(userID, s)
	if err != nil {
		return nil, err
	}
	result := make([]*model.Debt, len(debts))
	for i, d := range debts {
		result[i] = debtToModel(&d)
	}
	return result, nil
}

// Debt is the resolver for the debt field.
func (r *queryResolver) Debt(ctx context.Context, id uuid.UUID) (*model.Debt, error) {
	debt, err := r.Services.Debt.GetByID(id)
	if err != nil {
		return nil, err
	}
	return debtToModel(debt), nil
}

// IncomeCategories is the resolver for the incomeCategories field.
func (r *queryResolver) IncomeCategories(ctx context.Context) ([]*model.IncomeCategory, error) {
	userID, ok := middleware.GetUserID(ctx)
	if !ok {
		return nil, utils.ErrUnauthorized
	}
	cats, err := r.Services.IncomeCategory.GetByUserID(userID)
	if err != nil {
		return nil, err
	}
	result := make([]*model.IncomeCategory, len(cats))
	for i, c := range cats {
		result[i] = incomeCategoryToModel(&c)
	}
	return result, nil
}

// IncomeCategory is the resolver for the incomeCategory field.
func (r *queryResolver) IncomeCategory(ctx context.Context, id uuid.UUID) (*model.IncomeCategory, error) {
	cat, err := r.Services.IncomeCategory.GetByID(id)
	if err != nil {
		return nil, err
	}
	return incomeCategoryToModel(cat), nil
}

// Incomes is the resolver for the incomes field.
func (r *queryResolver) Incomes(ctx context.Context, filter *model.IncomeFilter) (*model.IncomesWithSummary, error) {
	userID, ok := middleware.GetUserID(ctx)
	if !ok {
		return nil, utils.ErrUnauthorized
	}
	var repoFilter *repository.IncomeFilter
	if filter != nil {
		repoFilter = &repository.IncomeFilter{
			CategoryID: filter.CategoryID,
		}
		if filter.IncomeType != nil {
			v := models.IncomeType(*filter.IncomeType)
			repoFilter.IncomeType = &v
		}
		if filter.StartDate != nil {
			s := filter.StartDate.Format("2006-01-02")
			repoFilter.StartDate = &s
		}
		if filter.EndDate != nil {
			e := filter.EndDate.Format("2006-01-02")
			repoFilter.EndDate = &e
		}
	}
	incomes, err := r.Services.Income.GetByUserID(userID, repoFilter)
	if err != nil {
		return nil, err
	}

	// Convert to model
	items := make([]*model.Income, len(incomes))
	for i, inc := range incomes {
		items[i] = incomeToModel(&inc)
	}

	// Calculate summary
	summary := calculateIncomeSummary(incomes)

	return &model.IncomesWithSummary{
		Items:   items,
		Summary: summary,
	}, nil
}

// Income is the resolver for the income field.
func (r *queryResolver) Income(ctx context.Context, id uuid.UUID) (*model.Income, error) {
	inc, err := r.Services.Income.GetByID(id)
	if err != nil {
		return nil, err
	}
	return incomeToModel(inc), nil
}

// RecurringIncomes is the resolver for the recurringIncomes field.
func (r *queryResolver) RecurringIncomes(ctx context.Context, isActive *bool) ([]*model.RecurringIncome, error) {
	userID, ok := middleware.GetUserID(ctx)
	if !ok {
		return nil, utils.ErrUnauthorized
	}
	ris, err := r.Services.RecurringIncome.GetByUserID(userID, isActive)
	if err != nil {
		return nil, err
	}
	result := make([]*model.RecurringIncome, len(ris))
	for i, ri := range ris {
		result[i] = recurringIncomeToModel(&ri)
	}
	return result, nil
}

// RecurringIncome is the resolver for the recurringIncome field.
func (r *queryResolver) RecurringIncome(ctx context.Context, id uuid.UUID) (*model.RecurringIncome, error) {
	ri, err := r.Services.RecurringIncome.GetByID(id)
	if err != nil {
		return nil, err
	}
	return recurringIncomeToModel(ri), nil
}

// Balance is the resolver for the balance field.
func (r *queryResolver) Balance(ctx context.Context, filter model.BalanceFilterInput) (*model.BalanceReport, error) {
	userID, ok := middleware.GetUserID(ctx)
	if !ok {
		return nil, utils.ErrUnauthorized
	}

	var startDate, endDate *time.Time
	if filter.StartDate != nil {
		startDate = filter.StartDate
	}
	if filter.EndDate != nil {
		endDate = filter.EndDate
	}

	report, err := r.Services.Balance.GetBalance(userID, services.BalanceFilterInput{
		Period:    services.BalancePeriod(filter.Period),
		StartDate: startDate,
		EndDate:   endDate,
	})
	if err != nil {
		return nil, err
	}

	return balanceReportToModel(report), nil
}

// UpcomingPayments is the resolver for the upcomingPayments field.
func (r *queryResolver) UpcomingPayments(ctx context.Context, filter model.UpcomingPaymentsFilter) (*model.UpcomingPaymentsReport, error) {
	userID, ok := middleware.GetUserID(ctx)
	if !ok {
		return nil, utils.ErrUnauthorized
	}

	report, err := r.Services.UpcomingPayments.GetUpcomingPayments(userID, filter.Month, filter.Year)
	if err != nil {
		return nil, err
	}

	return upcomingPaymentsReportToModel(report), nil
}

// ActualPayments is the resolver for the actualPayments field.
func (r *queryResolver) ActualPayments(ctx context.Context, filter model.ActualPaymentsFilter) (*model.ActualPaymentsReport, error) {
	userID, ok := middleware.GetUserID(ctx)
	if !ok {
		return nil, utils.ErrUnauthorized
	}

	report, err := r.Services.ActualPayments.GetActualPayments(userID, filter.StartDate, filter.EndDate)
	if err != nil {
		return nil, err
	}

	return actualPaymentsReportToModel(report), nil
}

// Dashboard is the resolver for the dashboard field.
func (r *queryResolver) Dashboard(ctx context.Context) (*model.Dashboard, error) {
	userID, ok := middleware.GetUserID(ctx)
	if !ok {
		return nil, utils.ErrUnauthorized
	}
	dash, err := r.Services.Dashboard.GetDashboard(userID)
	if err != nil {
		return nil, err
	}
	return dashboardToModel(dash), nil
}

// SavingsGoals is the resolver for the savingsGoals field.
func (r *queryResolver) SavingsGoals(ctx context.Context, status *model.SavingsGoalStatus) ([]*model.SavingsGoal, error) {
	userID, ok := middleware.GetUserID(ctx)
	if !ok {
		return nil, utils.ErrUnauthorized
	}

	var modelStatus *models.SavingsGoalStatus
	if status != nil {
		s := models.SavingsGoalStatus(*status)
		modelStatus = &s
	}

	goals, err := r.Services.SavingsGoal.GetByUserID(userID, modelStatus)
	if err != nil {
		return nil, err
	}

	result := make([]*model.SavingsGoal, len(goals))
	for i, g := range goals {
		result[i] = savingsGoalToModel(&g)
	}
	return result, nil
}

// SavingsGoal is the resolver for the savingsGoal field.
func (r *queryResolver) SavingsGoal(ctx context.Context, id uuid.UUID) (*model.SavingsGoal, error) {
	goal, err := r.Services.SavingsGoal.GetByID(id)
	if err != nil {
		return nil, err
	}
	return savingsGoalToModel(goal), nil
}

// Accounts is the resolver for the accounts field.
func (r *queryResolver) Accounts(ctx context.Context) ([]*model.Account, error) {
	userID, ok := middleware.GetUserID(ctx)
	if !ok {
		return nil, utils.ErrUnauthorized
	}
	accs, err := r.Services.Account.GetAccounts(userID)
	if err != nil {
		return nil, err
	}
	result := make([]*model.Account, len(accs))
	for i, a := range accs {
		result[i] = accountToModel(&a)
	}
	return result, nil
}

// Account is the resolver for the account field.
func (r *queryResolver) Account(ctx context.Context, id uuid.UUID) (*model.Account, error) {
	_, ok := middleware.GetUserID(ctx)
	if !ok {
		return nil, utils.ErrUnauthorized
	}
	acc, err := r.Services.Account.GetAccount(id)
	if err != nil {
		return nil, err
	}
	return accountToModel(acc), nil
}

// AccountsByType is the resolver for the accountsByType field.
func (r *queryResolver) AccountsByType(ctx context.Context, accountType model.AccountType) ([]*model.Account, error) {
	userID, ok := middleware.GetUserID(ctx)
	if !ok {
		return nil, utils.ErrUnauthorized
	}
	accs, err := r.Services.Account.GetAccountsByType(userID, models.AccountType(accountType))
	if err != nil {
		return nil, err
	}
	result := make([]*model.Account, len(accs))
	for i, a := range accs {
		result[i] = accountToModel(&a)
	}
	return result, nil
}

// Transactions is the resolver for the transactions field.
func (r *queryResolver) Transactions(ctx context.Context, filter *model.TransactionFilter) ([]*model.Transaction, error) {
	userID, ok := middleware.GetUserID(ctx)
	if !ok {
		return nil, utils.ErrUnauthorized
	}
	var txs []models.Transaction
	var err error
	if filter != nil && filter.StartDate != nil && filter.EndDate != nil {
		txs, err = r.Services.Ledger.GetTransactionsByDateRange(
			userID,
			filter.StartDate.Format("2006-01-02"),
			filter.EndDate.Format("2006-01-02"),
		)
	} else {
		txs, err = r.Services.Ledger.GetTransactionsByDateRange(userID, "", "")
	}
	if err != nil {
		return nil, err
	}
	result := make([]*model.Transaction, len(txs))
	for i, t := range txs {
		result[i] = transactionToModel(&t)
	}
	return result, nil
}

// Transaction is the resolver for the transaction field.
func (r *queryResolver) Transaction(ctx context.Context, id uuid.UUID) (*model.Transaction, error) {
	_, ok := middleware.GetUserID(ctx)
	if !ok {
		return nil, utils.ErrUnauthorized
	}
	tx, err := r.Services.Ledger.GetTransaction(id)
	if err != nil {
		return nil, err
	}
	return transactionToModel(tx), nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
